'use strict'
var multimatch = require('multimatch')
var utils = require('./utils.js')

var check_memory = exports.check_memory =
function check_memory(max_memory_rss, log) {
  if (max_memory_rss && process.memoryUsage) {
    var mem = process.memoryUsage()
    if (mem.rss > max_memory_rss) {
      if (log) {
        console.log(mem)
      }
      if (global.gc) {
        try {
          global.gc()
        } catch (e) {
          if (log) {
            console.log('Error of GC: ', e);
          }
        }
        if (log) {
          console.log('After GC: ', process.memoryUsage())
        }
      }
    }
  }
}

var is_multimatch = exports.is_multimatch =
function is_multimatch(files, pattern) {
  return multimatch(files, utils.flatten(pattern)).length > 0
}

var process_file = exports.process_file =
function process_file (pre, transform, post, conf_arr, file, name) {
  var path = file.path || name
  var will_change = is_multimatch([path, name],
                                  conf_arr.map(function(conf){return conf.pattern}))
  if (!will_change) {
    return
  }
  file.contents = post(conf_arr.reduce(
      function(content, conf) {
        if (!is_multimatch([path, name], conf.pattern)) {
          return content
        }
        return transform(content, conf, name, file)
      },
      pre(file.contents, name, file)
    ))

  var log = conf_arr.some(function(conf){return conf.log})
  var memory_conf = utils.find(conf_arr,
                                  function(conf){return conf.max_memory_rss})
  var max_memory_rss = memory_conf && memory_conf.max_memory_rss
  check_memory(max_memory_rss, log)
  return file.contents
}

var prepare_config = exports.prepare_config =
function prepare_config (def_conf, a, b) {
  if (utils.is_array(b)) {
    return prepare_config(def_conf, b.map(function(conf) {
      return utils.fill_defaults(conf, a)
    }))
  }

  if (!utils.is_array(a)) {
    return prepare_config(def_conf, [a])
  }

  return a.map(function(conf) {
    return utils.fill_defaults(conf, def_conf)
  })
}


/**
 * `plugin_name` - string that will be used in log.
 *
 * p - object of properties:
 * * `def_conf` - default configuration for `use`
 * * `metadataise` - `fn(metadata, conf)->conf`
 *     function that transforms configuration accordint
 *     to `metalsmith.metadata()`
 * * `pre` - `fn(content, name, file)->intermediate_content`
 *     function to transform content before each config_item processing
 *     is started. In other words it prepares file to transfomration.
 * * transform - `fn(intermediate_content, conf, name, file)->content`
 *     function that transforms content according to each conf item.
 * * `post` - `fn(intermediate_content)->content`
 *     function that concludes transformations of contents and converts it
 *     to final publicable view.
 *
 * all other args - configs:
 * 1. object of configs - for atomic transformations
 * 2. array of configs - every file will be passed to many transformations
 * 3. object + array - properties of object will be applied as defaults to
 *     objects from array
 */
var to_use = exports.to_use =
function to_use (plugin_name, p, __args) {
  //{:keys [def-conf metadataise pre transform post]}
  var args = Array.prototype.slice.call(arguments, 1)
  args[0] = p.def_conf
  var conf_arr = prepare_config.apply(null, args)
  var log = conf_arr.some(function(conf){return conf.log})
  var memory_conf = utils.find(conf_arr, function(conf){return conf.max_memory_rss})
  var max_memory_rss = memory_conf && memory_conf.max_memory_rss

  return function usable(files, metalsmith, done) {
    check_memory(max_memory_rss, log)
    var start_time = new Date().getTime()
    var metadata = metalsmith && metalsmith.metadata()
    conf_arr = conf_arr.map(
        utils.curry(
          p.metadataise, 
          metadata))
    if (typeof p.onstart == 'function') {
      p.onstart(conf_arr)
    }
    for (var name in files) {
      process_file(p.pre, p.transform, p.post, conf_arr, files[name], name)
    }
    if (log) {
      var end_time = new Date().getTime()
      console.log(plugin_name
        + ' done: ' + ((end_time - start_time) / 1000) + 's.')
    }
    if (typeof p.ondone == 'function') {
      p.ondone()
    }
    done()
  }
}

