'use strict'

var is_string = exports.is_string = function is_string (a) {
  return typeof a === 'string'
}

var is_array = exports.is_array = Array.isArray || function is_array(a) {
  return !is_string(a) && Object.prototype.toString.call(a) === '[object Array]';
}

var is_object = exports.is_object = function is_object(a) {
  return !!a && (typeof a === 'object') && !is_array(a)
}

var flatten = exports.flatten = 
function flatten (arr) {
  if (!is_array(arr)) {
    return [arr]
  }

  if (arr.length == 0) {
    return arr
  }

  return Function.prototype.call.apply(
    Array.prototype.concat,
    arr.map(flatten))
}

var extend_obj = exports.extend_obj =
function extend_obj (what, how) {
  for (var k in how) {
    what[k] = how[k]
  }
  return what
}

var fill_defaults = exports.fill_defaults =
function fill_defaults (what, defaults) {
  for (var k in defaults) {
    if (what[k] === undefined) {
        what[k] = defaults[k]
    }
  }
  return what
}

var find = exports.find =
function find(arr, predicate, scope) {
  if (Array.prototype.find) {
    return arr.find(callback, scope)
  }

  if (arr === null) {
    throw new TypeError('find called on null or undefined');
  }
  if (typeof predicate !== 'function') {
    throw new TypeError('predicate must be a function');
  }
  var list = Object(arr);
  var length = list.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = list[i];
    if (predicate.call(scope, value, i, list)) {
      return value;
    }
  }
  return undefined;
}

var curry = exports.curry =
function curry (fun, _args) {
  // arguments[0] = null
  // return Function.prototype.bind.apply(fun, arguments)
  var slice = Array.prototype.slice 
  var args = slice.call(arguments, 1)
  var result_fun = function(_rest) {
    return fun.apply(this, args.concat(slice.call(arguments)))
  }
  result_fun.orig_name = fun.name
  return result_fun
}






