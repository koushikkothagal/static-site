'use strict'

var ms = require('./metalsmithable.js')
var utils = require('./utils.js')
var curry = utils.curry
var paths = require('./paths.js')
var prefixize = paths.prefixize
var is_relative = paths.is_relative
var parser = require('./parser.js')

var namespace = function(namespace, context) {
    var prevIndex = 0;
    var nextIndex = namespace.indexOf('.', 0);
    var parent = context || window;

    do
    {
        nextIndex = namespace.indexOf('.', prevIndex);
        var key = nextIndex >= 0 ? namespace.substring(prevIndex, nextIndex) : namespace.substring(prevIndex);
        parent[key] = parent[key] || {};
        parent = parent[key];
        prevIndex = nextIndex + 1;
    }
    while(nextIndex >= 0);

    return parent;
}

function is_html (text) {
    return paths.ends_with(text.trim(), '</html>')
}


var default_is_current = function(current_url, url) {
    return url == current_url
        || url == current_url + '/'
        || url == current_url + '/index.html';
};


function add_class (classes, class_to_add) {
  return !class_to_add ? classes
       : !classes ? class_to_add
       : classes + ' ' + class_to_add
}

function add_classes (conf, tag_obj) {
  var tag = tag_obj.tag.toLowerCase()
  var classes = tag_obj.attrs['class']
  classes = add_class(classes, conf.all_links_class)
  if (tag == 'span') {
    classes = add_class(classes, conf.spans_class)
  } else if (tag == 'a') {
    classes = add_class(classes, conf.links_class)
  }
  if (classes) {
    tag_obj.attrs['class'] = classes
  }
}

function convert_html_files_to_folders (str) {
    return paths.ends_with(str, 'index.html')
                ? str.substring(0, str.length - 'index.html'.length)
         : paths.ends_with(str, '.html')
                ?str.substring(0, str.length - '.html'.length) + '/'
         : str
}

function prepare_file_path(conf, name, file) {
  var path = file.path || name

  var tr_f_p = conf.transform_file_path
            && (typeof conf.transform_file_path == 'function'
                || convert_html_files_to_folders)

  if (tr_f_p) {
    path = tr_f_p(path)
  }

  if (path.charAt(0) != '/') {
    path = '/' + path
  }

  return path
}











function metadataise (metadata, conf) {
  var prefix = conf.prefix
            || conf.meta && namespace(conf.meta, metadata)
            || ''
  return utils.extend_obj(
    utils.extend_obj({}, conf),
    {prefix: prefix})
}

function pre(env, content) {
  var html = content.toString();
  return {updaters: [], html: html}
}

function transform(obj, conf, name, file) {
  var updaters = obj.updaters
  var tag = conf.tag && conf.tag.toLowerCase() || 'a'
  var attr = conf.attr || 'href'
  var path = prepare_file_path(conf, name, file)

  var transform_url = conf.transform
    || curry(prefixize,
             conf.prefix,
             conf.convert_relatives && path)
  var current_url = transform_url(path)
  var is_current = conf.is_current || default_is_current

  updaters.push(function(tag_obj) {
    if (tag_obj.tag.toLowerCase() != tag) {
      return tag_obj
    }
    var attrs = tag_obj.attrs
    var url = attrs[attr]
    if (!url) {
      return tag_obj
    }

    var t_url = transform_url(url)
    var abs_url = is_relative(t_url)
      ? prefixize(conf.prefix, path, t_url)
      : t_url
    attrs[attr] = t_url
    if (conf.span_currents && tag == 'a'
        && is_current(current_url, abs_url)) {
      tag_obj.tag = 'span'
    }
    add_classes(conf, tag_obj)
    return tag_obj
  })
  return obj
}

function post (obj) {
  return parser.update_html(obj.html, obj.updaters)
}


/**
 * ## Config params: 
 * `meta: 'site.url'` - (optional) will take prefix from metadata.site.url
 * `prefix: '/base/url'` - (optional) take prefix from config:
 * `tag: 'script'` - (optional, default: 'a') tag selects affected elements
 * `attr: 'src'` - (optional, default: 'href') attr with URL to modify
 * `span_currents: true` - (optional) will replace links to current page with <span> elements.
 * `is_current: function(current_url, url)` - (optional) will recognize if link is current
 * `convert_relatives: false` - (optional) converts relatives to absolutes, works if `tranfrom` is undefined
 * `pattern: ['*.md'] - (optional) process only satisfied files. Default: `['**\/*.md', '**\/*.html`, '**\/*.htm']`
 * `transform_file_path` - (optional) bool or function. Default `false`. If `true` it replaces `.html` with `/` to recognize if path is current. It does not affect `path` field. If function `str -> str` is passed then prefixoid converts path with it.
 * `links_class: 'a-link'` - css class of <a> links.
 * `spans_class: 'span-link'` - css class of spans which were links.
 * `all_links_class: 'all-link'` - css class of every link processed with plugin
 * `transform: function` - (optional) transforms url
 */
module.exports = function(config, log, max_memory_rss) {
  var env = {}
  return ms.to_use('prefixoid', {
                      def_conf: {
                        log: log,
                        max_memory_rss: max_memory_rss,
                        pattern: ['**/*.md', '**/*.html', '**/*.htm']
                      },
                      onstart: function(conf_arr) {
                        if (conf_arr.some(function(conf){return conf.selector})) {
                          throw Error('The `selector` configuration property is replaced with `tag` property in version "1.0.0"')
                        }
                      },
                      metadataise: metadataise,
                      pre: curry(pre, env),
                      transform: transform,
                      post: post
                    },
                    config)
}








